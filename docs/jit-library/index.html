<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="keywords" content="WebAssembly,wasm,中文,文档,中文文档"/>
  <meta name="description" content="WebAssembly 中文文档"/>
  <title>JIT 和优化 - WebAssembly</title>
  <link rel="stylesheet" type="text/css" href="/css/custom.css">
</head>


<body>
  <header class="page-section-spacious">
    <div class="container">
    <div class="site-logo">
      <h1 class="title">WebAssembly</h1>
    </div>
    <nav class="site-nav">
      <a class="site-nav-item btn" href="/">总览</a>
      <a class="site-nav-item btn" href="/demo/">实例</a>
      <a class="site-nav-item btn" href="/getting-started/developers-guide/">快速开始</a>
      
      
      <a class="site-nav-item btn" href="/docs/js/">文档</a>
      <a class="site-nav-item btn" href="/community/feedback/">社区</a>
      <a class="site-nav-item btn" href="/roadmap/">规划</a>
      <a class="site-nav-item btn" href="/docs/faq/">问答</a>
      <a href="https://github.com/int64ago/wasm-cn" target="_blank">
        <img style="vertical-align: middle" width="74" height="20" src="https://img.shields.io/github/stars/int64ago/wasm-cn.svg?style=social&label=Star">
      </a>
    </nav>
    </div>
  </header>
  <section class="banner-update">
    <div class="container">
      <div class="banner-update-icon"></div>
      <span class="banner-update-date"></span>
      <span>WebAssembly 初版规范已由各个浏览器厂商达成共识，<a href="/roadmap/">了解更多</a></span>
    </div>
  </section>
  

<section>
  <div class="container">
    <div class="row">
      <div class="col-xs-12 col-lg-9 col-pop">
        <h1 id="jit-和优化">JIT 和优化</h1>

<p>WebAssembly’s
<a href="../future-features/#platform-independent-just-in-time-jit-compilation">Just-in-Time compilation (JIT)</a>
interface will likely be fairly low-level, exposing general-purpose primitives
rather than higher-level functionality. Still, there is a need for higher-level
functionality, and for greater flexibility than the WebAssembly spec can provide.
There is also a need for experimentation, particularly in the area of
applications wishing to dynamically generate new code, to determine which features
and interfaces are most appropriate. JIT and Optimization libraries that would run
inside WebAssembly and provide support and higher-level features would fit this
need very well.</p>

<p>Such libraries wouldn’t be part of the WebAssembly spec itself, but the concept
is relevant to discuss here because features that we can expect to address in
libraries are features that we may not need to add to the spec. This strategy
can help keep the spec itself simple and reduce the surface area of features
required of every spec implementation.</p>

<p>And, libraries will facilitate light-weight experimentation with new features
that we may eventually want to add to WebAssembly itself. In a library layer,
we can quickly iterate, experiment, and gain real-world insight, before adding
features to the spec itself and freezing all the details. And as new features
are standardized, libraries will become the polyfills which will help those
features gain adoption.</p>

<p>This raises the question of how we should decide which features belong in the
spec, and which belong in a library. Some of the fundamental advantages of
putting functionality in a library rather than in the spec and in implementations
themselves include:</p>

<ul>
  <li>A library can freely choose to offer greater degrees of undefined behavior,
implementation-defined behavior, unspecified behavior, and so on. This means
it can perform much more aggressive optimizations, including many that are
extremely common in optimizing compilers and might otherwise seem missing in
the WebAssembly spec itself:
    <ul>
      <li>Constant folding, strength reduction, and code motion of math functions
such as <code class="highlighter-rouge">sin</code>, <code class="highlighter-rouge">cos</code>, <code class="highlighter-rouge">exp</code>, <code class="highlighter-rouge">log</code>, <code class="highlighter-rouge">pow</code>, and <code class="highlighter-rouge">atan2</code>.</li>
      <li>Performing aggressive expression simplifications that depend on assuming
that integer arithmetic doesn’t overflow.</li>
      <li>Performing GVN with redundant load elimination, and other optimizations
based on aliasing rules that incur undefined behavior if they are violated.</li>
      <li>Vectorization that utilizes both floating point reassociation and
awareness of the underlying platform through
<a href="../feature-test/">feature testing</a>.</li>
    </ul>
  </li>
  <li>A library can support higher-level features, and features that are tailored
to certain applications, whereas the WebAssembly spec itself is limited to
general-purpose primitives. Possible examples of this are:
    <ul>
      <li>A richer type system, which could include things like complex, rational,
arbitrary bitwidth integers, non-power-of-2 SIMD types, interval
arithmetic, etc.</li>
      <li>A higher-level type system, which could include basic polymorphism of
various kinds (either with true dynamism or with monomorphisation).</li>
      <li>Richer control flow constructs.</li>
      <li>A broader set of operators, such as string-handling operators,
data type serialization, testing facilities, and linear algebra
operators, all of which can benefit from being integrated at the
language level.
Since every feature required in the spec itself will need to be implemented
by all implementations, domain-specific features run the risk of making
people “pay for what they don’t use”. With features libraries, people need
only pay for the features they choose to use.</li>
    </ul>
  </li>
  <li>A library can evolve over time to meet the changing needs of higher-level
languages. In practice, compiler IRs such as LLVM IR evolve to add new
features, change existing features, and sometimes remove features, and these
kinds of changes are much harder to do in a spec.</li>
</ul>

<p>The library approach also means that applications using a particular version
of a library can get consistent behavior and performance, because of the
determinism of the underlying WebAssembly platform.</p>

<p>A significant range of approaches are possible:</p>

<ul>
  <li>
    <p>“Customized WebAssembly”. This might involve a library whose input format
is conceptually WebAssembly but with some additional features. The library
could optimize and then lower those features leaving standard WebAssembly
to present to the underlying implementation.</p>
  </li>
  <li>
    <p>“Bring Your Own Compiler” There’s nothing stopping one from bundling
full-fledged AOT-style compilers that compile an independent source language
or IR into WebAssembly right there in WebAssembly itself. Obviously this
will involve tradeoffs in terms of download size and startup time, but it
would allow a unique degree of flexibility.</p>
  </li>
  <li>
    <p>And many things in between.</p>
  </li>
</ul>

      </div>
      <div class="col-xs-12 col-lg-3">
        <h6 class="side-title">文档</h6>
        <nav class="side-nav">
        
        
          
        
          
        
          
          <a class="side-nav-item" href="/docs/js/">JavaScript API</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
          <a class="side-nav-item" href="/docs/binary-encoding/">二进制编码</a>
          
        
          
          <a class="side-nav-item" href="/docs/c-and-c++/">C/C++ 开发指南</a>
          
        
          
        
          
          <a class="side-nav-item" href="/docs/dynamic-linking/">动态链接</a>
          
        
          
        
          
          <a class="side-nav-item" href="/docs/faq/">问答</a>
          
        
          
          <a class="side-nav-item" href="/docs/feature-test/">特性测试</a>
          
        
          
          <a class="side-nav-item" href="/docs/future-features/">未来支持特性</a>
          
        
          
          <a class="side-nav-item" href="/docs/gc/">GC / DOM / Web API 集成</a>
          
        
          
          <a class="side-nav-item" href="/docs/high-level-goals/">WebAssembly 整体目标</a>
          
        
          
          <a class="side-nav-item" href="/docs/jit-library/">JIT 和优化</a>
          
        
          
          <a class="side-nav-item" href="/docs/mvp/">最小可行产品</a>
          
        
          
          <a class="side-nav-item" href="/docs/modules/">模块</a>
          
        
          
          <a class="side-nav-item" href="/docs/non-web/">非 Web 环境集成</a>
          
        
          
          <a class="side-nav-item" href="/docs/nondeterminism/">不确定性</a>
          
        
          
          <a class="side-nav-item" href="/docs/portability/">可移植性</a>
          
        
          
          <a class="side-nav-item" href="/docs/rationale/">设计原理</a>
          
        
          
          <a class="side-nav-item" href="/docs/security/">安全</a>
          
        
          
          <a class="side-nav-item" href="/docs/semantics/">语义</a>
          
        
          
          <a class="side-nav-item" href="/docs/text-format/">文本格式</a>
          
        
          
          <a class="side-nav-item" href="/docs/tooling/">工具支持</a>
          
        
          
          <a class="side-nav-item" href="/docs/use-cases/">使用场景</a>
          
        
          
          <a class="side-nav-item" href="/docs/web/">Web 环境集成</a>
          
        
        </nav>
      </div>
    </div>
  </div>
</section>
</body>
</html>
