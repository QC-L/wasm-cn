<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="keywords" content="WebAssembly,wasm,中文,文档,中文文档"/>
  <meta name="description" content="WebAssembly 中文文档"/>
  <title>理解 JS API - WebAssembly</title>
  <link rel="stylesheet" type="text/css" href="/css/custom.css">
</head>


<body>
  <header class="page-section-spacious">
    <div class="container">
    <div class="site-logo">
      <h1 class="title">
        <img style="vertical-align: text-bottom;margin-right: 3px;" src="//avatars3.githubusercontent.com/u/11578470?v=3&s=32"><a href="/">WebAssembly 中文文档</a>
      </h1>
    </div>
    <nav class="site-nav">
      <a class="site-nav-item btn" href="/">总览</a>
      <a class="site-nav-item btn" href="/demo/">实例</a>
      <a class="site-nav-item btn" href="/getting-started/developers-guide/">快速开始</a>
      
      
      <a class="site-nav-item btn" href="/docs/js/">文档</a>
      <a class="site-nav-item btn" href="/community/feedback/">社区</a>
      <a class="site-nav-item btn" href="/roadmap/">规划</a>
      <a class="site-nav-item btn" href="/docs/faq/">问答</a>
      <a class="site-nav-item btn" style="color:#adadad" href="https://github.com/int64ago/wasm-cn" target="_blank">&#60;参与翻译/&#62;</a>
    </nav>
    </div>
  </header>
  <section class="banner-update">
    <div class="container">
      <div class="banner-update-icon"></div>
      <span class="banner-update-date"></span>
      <span>WebAssembly 初版规范已由各个浏览器厂商达成共识，<a href="/roadmap/">了解更多</a></span>
    </div>
  </section>
  

<section>
  <div class="container">
    <div class="row">
      <div class="col-xs-12 col-lg-9 col-pop">
        <h1 id="理解-js-api">理解 JS API</h1>

<p><em>我们假设你已经有了一个 .wasm 模块了，可以是 <a href="/getting-started/developers-guide/">直接从 C/C++ 编译得到</a> 或者 <a href="/getting-started/advanced-tools/#wabt-the-webassembly-binary-toolkit">从 S 表达式汇编得到</a></em></p>

<h2 id="加载并且运行">加载并且运行</h2>

<p>因为<a href="/docs/future-features/">未来支持特性</a>允许 WebAssembly 模块可以像 ES6 的模块一样进行加载（如： <code class="highlighter-rouge">&lt;script type='module'&gt;</code>），因此 WebAssembly 现在必须通过 JavaScript 加载，基本加载分为以下三个过程：</p>

<ul>
  <li>把 <code class="highlighter-rouge">.wasm</code> 里的字节放到一个指定类型的数组或者 <code class="highlighter-rouge">ArrayBuffer</code> 里</li>
  <li>把字节编译输出到 <code class="highlighter-rouge">WebAssembly.Module</code></li>
  <li>通过输入方法实例化 <code class="highlighter-rouge">WebAssembly.Module</code>，最终得到可以调用的输出</li>
</ul>

<p>下面详细解释下：</p>

<p>第一步是有很多方法得到类型化数组或者 <code class="highlighter-rouge">ArrayBuffer</code> ：网络（XHR 或 fetch）、从 IndexedDB 读取的 <code class="highlighter-rouge">File</code>、甚至直接通过 JavaScript 写方法得到</p>

<p>接下来编译字节使用的是异步方法 <code class="highlighter-rouge">WebAssembly.compile</code> ，返回一个 Promise 并且 resolves 传的是 <code class="highlighter-rouge">WebAssembly.Module</code> 。一个 <code class="highlighter-rouge">Module</code> 对象是无状态的并且支持<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">结构克隆</a>，这意味着编译好的代码可以直接存储在 IndexedDB 或者通过 <code class="highlighter-rouge">postMessage</code> 传输</p>

<p>最后一步的<em>实例化</em> <code class="highlighter-rouge">Module</code> 是通过把 <code class="highlighter-rouge">Module</code> 和其依赖的 <code class="highlighter-rouge">imports</code> 作为参数 new 一个 <code class="highlighter-rouge">WebAssembly.Instance</code>，<code class="highlighter-rouge">实例化</code>对象类似<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">函数闭包</a>，依赖上下文环境并且不可结构克隆</p>

<p>我们可以合并最后两步为一个<code class="highlighter-rouge">实例化</code>操作，输入为 <code class="highlighter-rouge">bytes</code> 和 <code class="highlighter-rouge">imports</code>，异步输出 <code class="highlighter-rouge">Instance</code>：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">instantiate</span><span class="p">(</span><span class="nx">bytes</span><span class="p">,</span> <span class="nx">imports</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">WebAssembly</span><span class="p">.</span><span class="nx">compile</span><span class="p">(</span><span class="nx">bytes</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">m</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">WebAssembly</span><span class="p">.</span><span class="nx">Instance</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">imports</span><span class="p">));</span>
<span class="p">}</span>
</code></pre>
</div>

<p>为了实战一把，我们先要介绍另一个 JS API：</p>

<h2 id="函数的导入和导出">函数的导入和导出</h2>

<p>类似 ES6 的模块，WebAssembly 也可以导出导出函数（后面还会介绍对象），先来看个简单例子，里面包含从 <code class="highlighter-rouge">imports</code> 里导入函数 <code class="highlighter-rouge">i</code> 并且最终导出为模块 <code class="highlighter-rouge">e</code>：</p>

<pre><code class="language-lisp">;; simple.wasm
(module
  (func $i (import "imports" "i") (param i32))
  (func (export "e")
    i32.const 42
    call $i))
</code></pre>

<p>（这里，我们没有通过写 C/C++ 代码然后编译为 WebAssembly，而是直接写<a href="/docs/text-format/">文本格式</a>代码然后<a href="/getting-started/advanced-tools/#wabt-the-webassembly-binary-toolkit">汇编</a>输出为二进制文件 <code class="highlighter-rouge">simple.wasm</code>）</p>

<p>从这个模块中我们可以得到一些信息：首先，WebAssembly 的输入有二级命名空间；这个例子里的内部名 <code class="highlighter-rouge">$i</code> 是从 <code class="highlighter-rouge">imports.i</code> 拿到的，简单说，我们必须从实例化对象参数里的 <code class="highlighter-rouge">imports</code> 对象里映射这个二级命名空间</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">importObject</span> <span class="o">=</span> <span class="p">{</span> <span class="na">imports</span><span class="p">:</span> <span class="p">{</span> <span class="na">i</span><span class="p">:</span> <span class="nx">arg</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">}</span> <span class="p">};</span>
</code></pre>
</div>

<p>把所有步骤放一起，我们可以通过一个简单的 Promise 链实例化我们的模块：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">fetch</span><span class="p">(</span><span class="s1">'simple.wasm'</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span> <span class="o">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">arrayBuffer</span><span class="p">())</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">bytes</span> <span class="o">=&gt;</span> <span class="nx">instantiate</span><span class="p">(</span><span class="nx">bytes</span><span class="p">,</span> <span class="nx">importObject</span><span class="p">))</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">instance</span> <span class="o">=&gt;</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">e</span><span class="p">());</span>
</code></pre>
</div>

<p>最后一行是执行我们导出的 WebAssembly 函数，最终实际上是调用导入的 JS 函数 <code class="highlighter-rouge">console.log(42)</code></p>

<h2 id="内存">内存</h2>

<p><a href="/docs/semantics/#linear-memory">线性内存</a> 是 WebAssembly 另一个很重要的概念，用于描述整个编译后的 C/C++ 程序的堆栈。从一个 JavaScript 程序员角度看的话，线性内存（或者简称为”内存“，下同）可以认为是一个可扩展的 <code class="highlighter-rouge">ArrayBuffer</code>，这个是被高度优化的，使其可以用尽可能少的资源维持一个沙箱环境</p>

<p>内存可以从 JavaScript 创建，可以制定初始值以及最大值：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">memory</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WebAssembly</span><span class="p">.</span><span class="nx">Memory</span><span class="p">({</span><span class="na">initial</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="na">maximum</span><span class="p">:</span><span class="mi">100</span><span class="p">});</span>
</code></pre>
</div>

<p>需要注意的是，<code class="highlighter-rouge">initial</code> 和 <code class="highlighter-rouge">maximum</code> 的单位是 <em>WebAssembly 页</em>，目前是固定的 64KB ，因此上面分配的内存实际是十页，或者说是 640KB，最大值是 6.4MB</p>

<p>因为大部分 JavaScript 的字节操作都可以直接作用于 <code class="highlighter-rouge">ArrayBuffer</code> 上，而不是额外定义一组不兼容的操作，<code class="highlighter-rouge">WebAssembly.Memory</code> 通过一个 返回值是 <code class="highlighter-rouge">ArrayBuffer</code> 的 <code class="highlighter-rouge">buffer</code> 指针来操纵它的字节。比如，需要在线性内存的第一个字节处写入 <code class="highlighter-rouge">42</code>：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="k">new</span> <span class="nx">Uint32Array</span><span class="p">(</span><span class="nx">memory</span><span class="p">.</span><span class="nx">buffer</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</code></pre>
</div>

<p>一旦内存区域创建了，内存的扩充可以通过调用 <code class="highlighter-rouge">Memory.prototype.grow</code> 实现：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">memory</span><span class="p">.</span><span class="nx">grow</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>如果达到了 <code class="highlighter-rouge">maximum</code>，继续尝试扩充会得到 <code class="highlighter-rouge">RangeError</code> 异常，引擎通过这种限制内存上限来保证更高效合理的使用内存</p>

<p>因为 <code class="highlighter-rouge">ArrayBuffer</code> 的 <code class="highlighter-rouge">byteLength</code> 是不能改变的，因此每次成功执行 <code class="highlighter-rouge">Memory.grow</code> 操作后，<code class="highlighter-rouge">buffer</code> 都会返回一个新的 <code class="highlighter-rouge">ArrayBuffer</code>（有新的 <code class="highlighter-rouge">byteLength</code>），之前的 <code class="highlighter-rouge">ArrayBuffer</code> 会变成一个游离的对象</p>

<p>跟函数一样，线性内存可以在模块内部定义也可以传进去。类似的，一个模块也可以导出其内存，这意味着 JavaScript 可以通过创建一个 <code class="highlighter-rouge">new WebAssembly.Memory</code> 并传入模块<em>或者</em>接收一个 <code class="highlighter-rouge">Memory</code> 的导出来访问 WebAssembly 的内存</p>

<p>例如，有个计算数组和的 WebAssembly 的模块（函数体被换成了 <code class="highlighter-rouge">...</code>）：</p>

<pre><code class="language-lisp">(module
  (memory (export "mem") 1)
  (func (export "accumulate") (param $ptr i32) (param $length i32) …))
</code></pre>

<p>这个模块导出了它的内存，假设模块叫 <code class="highlighter-rouge">instance</code>，我们可以使用导出的 <code class="highlighter-rouge">mem</code> 指针去操纵内部内存，如下：</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">i32</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint32Array</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">mem</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
  <span class="nx">i32</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">accumulate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</code></pre>
</div>

<p>内存<em>传参</em>原理跟函数传参类似，仅仅是 <code class="highlighter-rouge">Memory</code> 对象作为值传递，而不是 JS 函数。内存传参非常有用，主要由于以下两个原因：</p>

<ul>
  <li>允许 JavaScript 可以在模块编译前或者编译中获取或者设置内存的初始值</li>
  <li>允许一个 <code class="highlighter-rouge">Memory</code> 对象被多个实例传入，这对于实现 WebAssembly 的<a href="/docs/dynamic-linking">动态链接</a>至关重要</li>
</ul>

      </div>
      <div class="col-xs-12 col-lg-3">
        <h6 class="side-title">快速开始</h6>
        <nav class="side-nav">
          <a class="side-nav-item" href="/getting-started/developers-guide/">开发者指南</a>
          <a class="side-nav-item" href="/getting-started/js-api/">JS API</a>
          <a class="side-nav-item" href="/getting-started/advanced-tools/">高级工具</a>
          <a class="side-nav-item" href="https://developer.mozilla.org/en-US/docs/WebAssembly">MDN ↳</a>
        </nav>
      </div>
    </div>
  </div>
</section>
</body>
</html>
